// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Shooter.h"
#include "../Robotmap.h"
#include "math.h"
BSTimer* Shooter::fireTimer=NULL;
Shooter::Shooter() : Subsystem("Shooter") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	windowMotors = RobotMap::shooterWindowMotors;
	camLeft = RobotMap::shooterCamLeft;
	camRight = RobotMap::shooterCamRight;
	camPos = RobotMap::shooterCamPos;
	backupCamPos = RobotMap::shooterBackupCamPos;
	fingers = RobotMap::shooterFingers;
	ballNotPresent = RobotMap::shooterBallNotPresent;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	fireFlag = false;
	camMotorRatio = 1.0;
	fireSetpoint = 0;
	stage1Setpoint = 1.0;
	stage2Setpoint = .3;
	stressReliefSetpoint = 3.5;
	stressReliefComplete = true;
	resetCamComplete = true;
	fireTimer = new BSTimer();
	fireTimer->Start();
	fireDelayTimer = new BSTimer();
	fireDelayTimer->Start();
	fireDelayFlag = false;
	camPosStatus = true;
	backupCamPosStatus = true;
	previousCamPos = 0;
	previousBackupCamPos = 0;
	fireDelay = .3;
	resetBeaterBar = true;
}
    
void Shooter::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	previousCamPos = camPos->GetAverageVoltage();
	previousBackupCamPos = backupCamPos->GetAverageVoltage();
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void Shooter::CamChecker() {
	if(fireDelayTimer->HasPeriodPassed(fireDelay) && fireDelayFlag)
	{
		fireFlag = true;
		fireTimer->Reset();
		fireDelayFlag = false;
	}
	
	
	if(fireFlag && !fireTimer->HasPeriodPassed(3.0)) 
	{
		if(!fireTimer->HasPeriodPassed(.3)) {
			RunCams(1, false);
		}
		else {
			Reset();
		}
		if(resetBeaterBar && GetCorrectedCamPos() > 4.5 && GetCorrectedCamPos() < 4.0)
			RobotMap::pickupBeaterBarOut->Set(false);
	}
	else {
		fireFlag = false;
		RunCams(0, false);
	}
}

void Shooter::Fire(float delay, bool ResetBeaterBar) {
	//if(!GetFiring() && !ballNotPresent->Get()) {
	if(!GetFiring()) {
		fireDelayTimer->Reset();
		fireDelay = delay;
		fireDelayFlag = true;
		resetBeaterBar = ResetBeaterBar;
	}
}

void Shooter::RunCams(float output, bool forceRun) {
	float f_output;
	
	if(GetCorrectedCamPos() < 4.5 && GetCorrectedCamPos() > 4.3 && output < 0 && !forceRun)
		f_output = 0;
	else
		f_output = output;
	
	//if(GetCorrectedCamPos() < fireSetpoint && ballNotPresent->Get() && f_output > 0 && !forceRun)
	//	f_output = 0;
	
//	if(output == 1 &&  (previousCamPos - camPos->GetAverageVoltage()) < 0 && (camPos->GetAverageVoltage() - camPosOffset) > 0.5 && (camPos->GetAverageVoltage() - camPosOffset) < 4.5){ 
//		camPosStatus = false;
//	}
	if(output == 1 && fabs(previousCamPos - camPos->GetAverageVoltage()) < 0){ 
		camPosStatus = false;
	}
	
	if(output == 1 && fabs(previousBackupCamPos - backupCamPos->GetAverageVoltage()) < 0)
		backupCamPosStatus = false;
	
	if(!camPosStatus && !backupCamPosStatus && !forceRun)
		f_output = 0;
	
	previousCamPos = camPos->GetAverageVoltage();
	previousBackupCamPos = backupCamPos->GetAverageVoltage();
	
	windowMotors->Set(-f_output);
	camLeft->Set(-camMotorRatio*f_output);
	camRight->Set(-camMotorRatio*f_output);
	
}
bool Shooter::GetStressReliefComplete() {
	return stressReliefComplete;
}
bool Shooter::GetResetCamComplete() {
	return resetCamComplete;
}
void Shooter::RelieveStress() {
	if (GetCorrectedCamPos() < stressReliefSetpoint || GetCorrectedCamPos() > 4.9) 
	{
		RunCams(-0.5, false);
		stressReliefComplete = false;
		fireFlag = false;
		fireDelayFlag = false;
	}
	else
	{
		RunCams(0, false);
		stressReliefComplete = true;
	}
}
void Shooter::SetCamOffsets(float primaryOffset, float backupOffset){
	camPosOffset = primaryOffset;
	backupCamPosOffset = backupOffset;
}

void Shooter::Reset() {
	if(GetCorrectedCamPos() < 4.5) {	
		if(GetCorrectedCamPos() > stage1Setpoint) {
			resetCamComplete = false;
			RunCams(1, false);
		}
		else if (GetCorrectedCamPos() > fireSetpoint){
			RunCams(.6, false);
			resetCamComplete = false;
		}
		else {
			RunCams(0, false);
			resetCamComplete = true;
			fireFlag = false;
			fireDelayFlag = false;
		}
	}
	else {
		RunCams(0, false);
		resetCamComplete = true;
	}
		
}
bool Shooter::GetFiring() {
	return fireFlag && fireDelayFlag;
}
float Shooter::CorrectVoltage(float setpoint) {
	
	if (setpoint < 0)
	{
		return setpoint + 5;
	}
	else if (setpoint > 5)
	{
		return setpoint - 5;
	}
	else if (setpoint == 5)
	{
		return 0;
	}
	else
	{
		return setpoint;
	}
}
float Shooter::GetCorrectedCamPos(){
	float correctedVoltage;
	if(camPosStatus)
		correctedVoltage = CorrectVoltage(camPos->GetAverageVoltage()-camPosOffset);
	else
		correctedVoltage = CorrectVoltage(backupCamPos->GetAverageVoltage()-backupCamPosOffset);
		
	return correctedVoltage;
}
bool Shooter::GetCamPosStatus() {
	return camPosStatus;
}
bool Shooter::GetBackupCamPosStatus() {
	return backupCamPosStatus;
}
