// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Shooter.h"
#include "../Robotmap.h"
BSTimer* Shooter::fireTimer=NULL;
Shooter::Shooter() : Subsystem("Shooter") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	windowMotors = RobotMap::shooterWindowMotors;
	camLeft = RobotMap::shooterCamLeft;
	camRight = RobotMap::shooterCamRight;
	camPos = RobotMap::shooterCamPos;
	backupCamPos = RobotMap::shooterBackupCamPos;
	fingers = RobotMap::shooterFingers;
	ballNotPresent = RobotMap::shooterBallNotPresent;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	fireFlag = false;
	camMotorRatio = 1.0;
	fireSetpoint = 0.1;
	stressReliefSetpoint = 3.5;
	stressReliefComplete = true;
	resetCamComplete = true;
	fireTimer = new BSTimer();
	fireTimer->Start();
	fireDelayTimer = new BSTimer();
	fireDelayTimer->Start();
	fireDelayFlag = false;
	camPosStatus = true;
	backupCamPosStatus = false;
	previousCamPos = 0;
	previousBackupCamPos = 0;
	fireDelay = .3;
	resetBeaterBar = true;
}
    
void Shooter::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	previousCamPos = camPos->GetAverageVoltage();
	previousBackupCamPos = backupCamPos->GetAverageVoltage();
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void Shooter::CamChecker() {
	if(fireDelayTimer->HasPeriodPassed(fireDelay) && fireDelayFlag)
	{
		fireFlag = true;
		fireTimer->Reset();
		fireDelayFlag = false;
	}
	
	
	if(fireFlag && !fireTimer->HasPeriodPassed(3.0)) 
	{
		if(!fireTimer->HasPeriodPassed(.5) || GetCorrectedCamPos() > fireSetpoint) {
			RunCams(1, false);
			if(resetBeaterBar)
				RobotMap::pickupBeaterBarOut->Set(false);
		}
		else {
			fireFlag = false;
			RunCams(0, false);
		}
	}
	else {
		fireFlag = false;
		RunCams(0, false);
	}
	
	
	SmartDashboard::PutBoolean("FireFlag", fireFlag);
	SmartDashboard::PutBoolean("FireDelayFlag", fireDelayFlag);
}
void Shooter::Fire(float delay, bool ResetBeaterBar) {
	if(!fireDelayFlag && !ballNotPresent->Get()) {
		fireDelayTimer->Reset();
		fireDelay = delay;
		fireDelayFlag = true;
		resetBeaterBar = ResetBeaterBar;
	}
}
void Shooter::RunCams(float output, bool forceRun) {
	float f_output;
	
	if(GetCorrectedCamPos() > 0 && GetCorrectedCamPos() < 4.8 && !forceRun) 
		f_output = output;
	else if(output < 0 && !forceRun)
		f_output = 0;
	else
		f_output = output;
	
	if(GetCorrectedCamPos() < fireSetpoint && ballNotPresent->Get() && f_output > 0 && !forceRun)
		f_output = 0;
	
	if(output == 1 &&  (camPos->GetAverageVoltage() - previousCamPos) < -0.01 && (camPos->GetAverageVoltage() - camPosOffset) > 0.5 && (camPos->GetAverageVoltage() - camPosOffset) < 4.5){ 
		camPosStatus = false;
	}	
	
	if(output == 1 &&  (backupCamPos->GetAverageVoltage() - previousBackupCamPos) < -0.01 && (backupCamPos->GetAverageVoltage() - backupCamPosOffset) > 0.5 && (backupCamPos->GetAverageVoltage() - backupCamPosOffset) < 4.5)
		backupCamPosStatus = false;
	if(!camPosStatus && !backupCamPosStatus && !forceRun)
		f_output = 0;
	
	previousCamPos = camPos->GetAverageVoltage();
	previousBackupCamPos = backupCamPos->GetAverageVoltage();
	
	windowMotors->Set(-f_output);
	camLeft->Set(-camMotorRatio*f_output);
	camRight->Set(-camMotorRatio*f_output);
	
}
bool Shooter::GetStressReliefComplete() {
	return stressReliefComplete;
}
bool Shooter::GetResetCamComplete() {
	return resetCamComplete;
}
void Shooter::RelieveStress() {
	if (GetCorrectedCamPos() < stressReliefSetpoint) 
	{
		RunCams(-0.5, false);
		stressReliefComplete = false;
	}
	else
	{
		RunCams(0, false);
		stressReliefComplete = true;
	}
}
void Shooter::SetCamOffsets(float primaryOffset, float backupOffset){
	camPosOffset = primaryOffset;
	backupCamPosOffset = backupOffset;
}
void Shooter::Reset() {
	if(GetCorrectedCamPos() > fireSetpoint) {
		RunCams(1, false);
		resetCamComplete = false;
	}
	else {
		RunCams(0, false);
		resetCamComplete = true;
	}
}
bool Shooter::GetFiring() {
	return fireFlag && fireDelayFlag;
}
float Shooter::CorrectVoltage(float setpoint) {
	
	if (setpoint < 0)
	{
		return setpoint + 5;
	}
	else if (setpoint > 5)
	{
		return setpoint - 5;
	}
	else if (setpoint == 5)
	{
		return 0;
	}
	else
	{
		return setpoint;
	}
}
float Shooter::GetCorrectedCamPos(){
	float correctedVoltage;
	if(camPosStatus)
		correctedVoltage = CorrectVoltage(camPos->GetAverageVoltage()-camPosOffset);
	else
		correctedVoltage = CorrectVoltage(backupCamPos->GetAverageVoltage()-backupCamPosOffset);
		
	return correctedVoltage;
}
bool Shooter::GetCamPosStatus() {
	return camPosStatus;
}
bool Shooter::GetBackupCamPosStatus() {
	return backupCamPosStatus;
}
